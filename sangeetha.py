# -*- coding: utf-8 -*-
"""sangeetha.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/181QKf1MSOyBw3PjYyaEnux13MoeGd_tW
"""

def torque(force,radius):
  return force*radius
print("Torque:",torque(50,0.3),"N.m")

machine={"name":"Lathe","Power":5.5,"unit":"kw"}
print("Machine:",machine["name"])
print("Power:",machine["Power"],machine["unit"])

tools={"wrench","hammer","screwdriver","hammer"}
print("Unique tools:",tools)

def slab_volume(length,width,thickness):
 return length*width*thickness
print("volume:",slab_volume(5,4,0.15),"m3")

project={"name":"Bridge","length":150,"status":"ongoing"}
print("project:",project["name"])
print("Length:",project["length"],"meters")

bases=[10,15,20]
heights=[5,8,12]
for base,height in zip(bases,heights):
  area=0.5*base*height
print(f"Area with base{base}and height{height}:{area}m2")

def voltage(current,resistance):
  return current*resistance
print("voltage:",voltage(2.5,10),"volts")

components={"resistors","capacitor","inductor","resistor"}
print("unique components:",components)

voltages=[230,120,12]
currents=[5,10,0.5]
for V,I in zip(voltages,currents):
 power=V*I
print(f"Power for voltage{V}V and current{I}A:{power}watts")

def gear_train_velocity_ratio(driver_teeth,driven_teeth):
   return driven_teeth/driver_teeth
driver=20
driven=60
vr=gear_train_velocity_ratio(driver,driven)
print("Velocity Ratio:",vr)

def stress(force,area):
 return force/area
def strain(change_length,original_length):
  return change_length/original_length
F=5000#N
A=0.001#m2
deltaL=0.002#m
L=2.0#m
print("Stress:",stress(F,A),"Pa")
print("Strain:",strain(deltaL,L))

def thermal_expansion(alpha,length,temp_change):
  return alpha*length*temp_change
alpha=12e-6
L=5.0#meters
deltaT=50# \degreeC
print("Expansion:",thermal_expansion(alpha,L,deltaT),"m")

def hazen_williams(Q,C,D):
#Q in m3/s,C:coefficient,D:diameter in m
 return(0.849*C*(D**2.63)*(Q**0.54))
flow=hazen_williams(0.05,150,0.3)
print("Head Loss(approx):",flow)

import math
def rlc_impedance(R,L,C,f):
  xl=2*math.pi*f*L
  xc=1/(2*math.pi*f*C)
  return math.sqrt(R**2+(xc-xl)**2)
R=100
L=0.5
C=1e-6
f=50
print("RLC Circuit impedance:",rlc_impedance(R,L,C,f),"ohms")

import math
def three_phase_power(V_line,l_line,power_factor):
  return math.sqrt(3)*V_line*l_line*power_factor
print("three-phase power:",three_phase_power(415,10,0.9),"watts")

def beam_ids(n):
  for i in range(1,n+1):
    yield f"B{i}"
for beam in beam_ids(3):
 print(beam)

beam_id="B12"
   length_m=5.5
   is_safe=True
materials=["steel","concrete"]

density=7850
volume=0.002
mass=density*volume
print("mass(kg):",mass)

stress=250
if stress>300:
  print("fail")
elif stress>250:
    print("near failure")
else:
      print("safe")

for load in[100,200,300]:
  print("load:",load)
  count=0
  while count<3:
    print("count:",count)
    count+=1

def beam_volume(l,b,h):
  return l*b*h
print("volume:",beam_volume(5,0.3,0.5))

#civil:slab areas
lengths=[4,5,6]
breadths=[3,3.5,4]
areas=[l*b for l,b in zip(lengths,breadths)]
print("areas",areas)
#mechanical:gear ratios
gear_data={"G1":(20,40),"G2":(15,45)}
ratios={k:driven/driving for k,(driving,driven) in gear_data.items()}
print(ratios)

efficiencies=[0.85,0.9,0.92,0.8]
high=list(filter(lambda e:e>0.88,efficiencies))
print("high efficiency:",high)
forces=[100,200,300]
distances=[2,3,4]
moments=[f*d for f,d in zip(forces,distances)]
print("moments:",moments)

def_init_(self,l,b,h,cost_per_m3)
    self.l=l
    self.b=b
    self.h=h
    self.cost_per_m3=cost_per_m3
  def volume(self):
    return self.l*self.b*self.h
  def total_cost(self):
    return self.volume() * self.cost_per_m3
slab=ConcreteSlab(10,5,0.2,3500)
print("Volume:",slab.volume(),"m3")
print("Total cost:",slab.total_cost(),"INR")

import math
class ThreePhasePower:
  def_init_(self,V,I,pf)
    self.V=V
    self.I=I
    self.pf=pf
def power(self):
  return math.sqrt(3)*self.V*self.I*self.pf
tp=ThreePhasePower(400,50,0.9)
print("ThreePhasePower:",round(tp.power(),2),"w")

try:
  darta=float(input('enter load value:'))
except valueerror:
    print('invalid input!enter a number.')

import json
with open('machine_config.json')as f:
 config=json.load(f)
print(config['motor']['rated_speed'])

#scipy for calculation
from scipy.optimize import fsolve
def eq(x):
  return 3*x**2-x-1
root=fsolve(eq,0)
print('Root:',root)

#monte carlo simulation
import numpy as np
samples=np.random.normal(50,5,10000)
failure_rate=np.mean(samples>60)
print('Failure Rate:',failure_rate*100,'%')

#Multi-processing
from multiprocessing import Pool
def square(n):
  return n*n
with Pool(4) as p:
 print(p.map(square,[1,2,3,4,5]))

#Data Fitting
import numpy as np
from scipy.optimize import curve_fit
def model(x,a,b):
  return a*np.exp(b*x)
x=np.linspace(0,4,50)
y=model(x,2,0.5)+np.random.normal(0,0.2,50)
popt,_=curve_fit(model,x,y)
print(popt)

import tkinter as tk
def calc():
 F=float(entry_force.get())
 A=float(entry_area.get())
 result.set(F/A)
root=tk.Tk()
entry_force=tk.entry(root)
entry_area=tk.entry(root)
results=tk.StringVar()
tk.Button(root,text='calc',command=calc).pack()
tk.Label(root,textvariable=result).pack()
root.mainloop()

#Excel Autamation
import pandas as pd
df=pd.read_excel('data.xlsx')
df['Stress']=df['Force']/df['Area']
df.to_excel('results.xlsx',index=False)

#Heat Transfer example
k=205;A=0.01;T1,T2=373,293;L=0.05
Q=(k*A*(T2-T1))/L
print(Q)

#vibration example
m,k=1.0,50.0
omega=np.sqrt(k/m)
t=np.linspace(0,2,200)
x=np.cos(omega*t)
import matplotlib.pyplot as plt
plt.plot(t,x);plt.show()

#Bending moment example
w,L=5,6
M_max=(w*L**2)/8
print(M_max)

#AC Circuit example
import cmath
V= 230;Z=10+5j
I=V/Z
print(I)

import numpy as np
arr=np.array([2,4,6,8])
print(arr)

Thirdyear_list=[10,50,100]
print("original:",Thirdyear_list)
Thirdyear_list.append(90)
Thirdyear_list[1]=90
print("update:",Thirdyear_list)

student_tuple=(1,4,3,2,6,7,8,9,4)
print("original:",student_tuple)
New_tuple=student_tuple+(15,34)
print("New_tuple:",New_tuple)

student_set={1,2,3,4,5,6,7,8,9,10}
print("original",student_set)
student_set.add(11)
student_set.add(15)
student_set.remove(8)
print("updated",student_set)

class Address:
    def __init__(self, street, city, state):
        self.street = street
        self.city = city
        self.state = state

S1 = Address("KVR petrol bunk", "Nellore", "AP")
print("self.street", S1.street)
print("self.city", S1.city)
print("self.state", S1.state)

#Signal processing-Digital filter design project 2.............
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, lfilter

# Create a noisy signal
fs = 1000  # Sampling frequency
t = np.linspace(0, 1.0, fs)
signal = np.sin(2 * np.pi * 5 * t)  # 5 Hz sine wave
noise = np.random.normal(0, 0.5, signal.shape)
noisy_signal = signal + noise

# Design a Low-pass Butterworth filter
def butter_lowpass(cutoff, fs, order=4):
    nyquist = 0.5 * fs
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return b, a

def apply_filter(data, cutoff, fs, order=4):
    b, a = butter_lowpass(cutoff, fs, order=order)
    y = lfilter(b, a, data)
    return y

# Apply filter
cutoff = 10  # Cut-off frequency in Hz
filtered_signal = apply_filter(noisy_signal, cutoff, fs)

# Plot results
plt.figure(figsize=(12,6))
plt.subplot(3,1,1)
plt.plot(t, signal, label="Original Signal")
plt.legend()

plt.subplot(3,1,2)
plt.plot(t, noisy_signal, label="Noisy Signal", color='red')
plt.legend()

plt.subplot(3,1,3)
plt.plot(t, filtered_signal, label="Filtered Signal", color='green')
plt.legend()

plt.show()

#DC motor speed control (PID simulation) project 1...............
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# --- DC motor parameters ---
J = 0.01   # kg·m^2
b = 0.1    # N·m·s
K = 0.01   # N·m/A  (also V·s/rad)
R = 1.0    # ohm
L = 0.5    # H

# Motor transfer function G(s) = K / (JLs^2 + (JR+Lb)s + (Rb + K^2))
numG = [K]
denG = [J*L, J*R + L*b, R*b + K**2]

# --- PID controller C(s) = Kd s + Kp + Ki/s = (Kd s^2 + Kp s + Ki) / s ---
Kp, Ki, Kd = 100.0, 200.0, 10.0
numC = [Kd, Kp, Ki]
denC = [1.0, 0.0]

# Open loop: OL(s) = C(s)G(s) = N(s)/D(s)
numOL = np.convolve(numC, numG)
denOL = np.convolve(denC, denG)

# Closed loop with unity feedback: T(s) = OL / (1 + OL) = N / (D + N)
numCL = numOL
denCL = np.polyadd(denOL, numOL)

# LTI system and step response
sys = signal.TransferFunction(numCL, denCL)
t = np.linspace(0, 2.0, 1000)
t, y = signal.step(sys, T=t)

plt.figure(figsize=(10, 6))
plt.plot(t, y, label="Speed (rad/s) for 1-rad/s step")
plt.xlabel("Time (s)")
plt.ylabel("Speed (rad/s)")
plt.title("DC Motor Speed Control with PID (SciPy only)")
plt.grid(True)
plt.legend()
plt.show()